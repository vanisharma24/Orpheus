// src/Orpheus_frontend/src/services/ic-agent.ts
import { Actor, HttpAgent } from '@dfinity/agent';
import { AuthClient } from '@dfinity/auth-client';
import { Principal } from '@dfinity/principal';

// These will be generated by dfx generate orpheus_backend
import { orpheus_backend } from '../declarations/orpheus_backend';
import {
  _SERVICE,
  CreateProjectRequest,
  Project,
  User,
  Track,
  MusicNFT,
  NFTMetadata,
  CreateUserRequest,
  AddTrackRequest
} from './src/Orpheus_frontend/Services/orpheus_backend_types';

const HOST =
  process.env.DFX_NETWORK === 'local'
    ? 'http://localhost:4943'
    : 'https://ic0.app';

class ICService {
  private authClient: AuthClient | null = null;
  private actor: _SERVICE | null = null;
  private agent: HttpAgent | null = null;
  private isInitialized = false;

  async init() {
    if (this.isInitialized) return;

    this.authClient = await AuthClient.create();

    if (await this.authClient.isAuthenticated()) {
      await this.setupActor();
    }

    this.isInitialized = true;
  }

  async login(): Promise<boolean> {
    if (!this.authClient) {
      await this.init();
    }

    return new Promise((resolve) => {
      this.authClient?.login({
        identityProvider:
          process.env.DFX_NETWORK === 'local'
            ? `http://localhost:4943/?canisterId=${process.env.CANISTER_ID_INTERNET_IDENTITY}`
            : 'https://identity.ic0.app',
        onSuccess: async () => {
          await this.setupActor();
          resolve(true);
        },
        onError: (error) => {
          console.error('Login failed:', error);
          resolve(false);
        }
      });
    });
  }

  async logout() {
    await this.authClient?.logout();
    this.actor = null;
    this.agent = null;
  }

  private async setupActor() {
    const identity = this.authClient?.getIdentity();

    this.agent = new HttpAgent({
      host: HOST,
      identity
    });

    // For local dev only
    if (process.env.DFX_NETWORK === 'local') {
      await this.agent.fetchRootKey().catch(console.error);
    }

    this.actor = Actor.createActor<_SERVICE>(orpheus_backend, {
      agent: this.agent,
      canisterId: process.env.CANISTER_ID_ORPHEUS_BACKEND!
    });
  }

  isAuthenticated(): boolean {
    return this.authClient?.isAuthenticated() || false;
  }

  getPrincipal(): Principal | null {
    return this.authClient?.getIdentity()?.getPrincipal() || null;
  }

  // --------------------
  // User Management
  // --------------------
  async createUser(userData: {
    username: string;
    email?: string;
    bio?: string;
    avatar?: string;
  }): Promise<Principal | null> {
    try {
      if (!this.actor) return null;

      const request: CreateUserRequest = {
        username: userData.username,
        email: userData.email ? [userData.email] : [],
        bio: userData.bio ? [userData.bio] : [],
        avatar: userData.avatar ? [userData.avatar] : []
      };

      const result = await this.actor.create_user(request);

      if ('Ok' in result) {
        return result.Ok;
      } else {
        console.error('Failed to create user:', result.Err);
        return null;
      }
    } catch (error) {
      console.error('createUser error:', error);
      return null;
    }
  }

  async getUser(principal: Principal): Promise<User | null> {
    try {
      if (!this.actor) return null;

      const result = await this.actor.get_user(principal);

      if ('Ok' in result) {
        return result.Ok;
      } else {
        console.error('Failed to fetch user:', result.Err);
        return null;
      }
    } catch (error) {
      console.error('getUser error:', error);
      return null;
    }
  }

  // --------------------
  // Project Management
  // --------------------
  async createProject(projectData: CreateProjectRequest): Promise<Project | null> {
    try {
      if (!this.actor) return null;

      const result = await this.actor.create_project(projectData);

      if ('Ok' in result) {
        return result.Ok;
      } else {
        console.error('Failed to create project:', result.Err);
        return null;
      }
    } catch (error) {
      console.error('createProject error:', error);
      return null;
    }
  }

  async getProjectsByUser(principal: Principal): Promise<Project[]> {
    try {
      if (!this.actor) return [];

      const result = await this.actor.get_projects_by_user(principal);

      if ('Ok' in result) {
        return result.Ok;
      } else {
        console.error('Failed to fetch projects:', result.Err);
        return [];
      }
    } catch (error) {
      console.error('getProjectsByUser error:', error);
      return [];
    }
  }

  // --------------------
  // Track Management
  // --------------------
  async addTrack(trackData: AddTrackRequest): Promise<Track | null> {
    try {
      if (!this.actor) return null;

      const result = await this.actor.add_track(trackData);

      if ('Ok' in result) {
        return result.Ok;
      } else {
        console.error('Failed to add track:', result.Err);
        return null;
      }
    } catch (error) {
      console.error('addTrack error:', error);
      return null;
    }
  }

  // --------------------
  // NFT Management
  // --------------------
  async mintNFT(metadata: NFTMetadata): Promise<MusicNFT | null> {
    try {
      if (!this.actor) return null;

      const result = await this.actor.mint_nft(metadata);

      if ('Ok' in result) {
        return result.Ok;
      } else {
        console.error('Failed to mint NFT:', result.Err);
        return null;
      }
    } catch (error) {
      console.error('mintNFT error:', error);
      return null;
    }
  }
}

const icService = new ICService();
export default icService;
